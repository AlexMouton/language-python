{
-----------------------------------------------------------------------------
-- |
-- Module      : Language.Python.Version3.Parser.Parser 
-- Copyright   : (c) 2009 Bernie Pope 
-- License     : BSD-style
-- Maintainer  : bjpop@csse.unimelb.edu.au
-- Stability   : experimental
-- Portability : ghc
--
-- Implementation of the Python version 3 parser. Generated by happy. 
-----------------------------------------------------------------------------

module Language.Python.Version3.Parser.Parser (parseFileInput, parseSingleInput, parseEval) where

import Language.Python.Version3.Parser.Lexer
import Language.Python.Version3.Parser.Token hiding (True, False)
import qualified Language.Python.Version3.Parser.Token as Token
import Language.Python.Version3.Syntax.AST as AST
import Language.Python.Version3.Parser.ParserUtils
import Language.Python.Version3.Parser.ParserMonad
import Language.Python.Data.SrcLocation
import qualified Data.ByteString.Char8 as BS (ByteString)
import Data.Either (rights, either)
import Data.Maybe (maybeToList)
}

%name parseFileInput file_input 
%name parseSingleInput single_input 
%name parseEval eval_input

%tokentype { Token } 
%error { parseError } 
%monad { P } { thenP } { returnP }
%lexer { lexCont } { Token.EOF }

%token 
   '='             { Token.Assign _ }
   '('             { Token.LeftRoundBracket _ }
   ')'             { Token.RightRoundBracket _ }
   '['             { Token.LeftSquareBracket _ }
   ']'             { Token.RightSquareBracket _ }
   '{'             { Token.LeftBrace _ }
   '}'             { Token.RightBrace _ }
   ','             { Token.Comma _ }
   ';'             { Token.SemiColon _ }
   ':'             { Token.Colon _ }
   '+'             { Token.Plus _ }
   '-'             { Token.Minus _ }
   '*'             { Token.Mult _ }
   '**'            { Token.Exponent _ }
   '/'             { Token.Div _ }
   '//'            { Token.FloorDiv _ }
   '>'             { Token.GreaterThan _ }
   '<'             { Token.LessThan _ }
   '=='            { Token.Equality _ }
   '>='            { Token.GreaterThanEquals _ }
   '<='            { Token.LessThanEquals _ }
   '|'             { Token.BinaryOr _ }
   '^'             { Token.Xor _ }      
   '&'             { Token.BinaryAnd _ }      
   '>>'            { Token.ShiftLeft _ }
   '<<'            { Token.ShiftRight _ }
   '%'             { Token.Modulo _ }
   '~'             { Token.Tilde _ }
   '!='            { Token.NotEquals _ }
   '.'             { Token.Dot _ }
   '...'           { Token.Ellipsis _ }
   '+='            { Token.PlusAssign _ }
   '-='            { Token.MinusAssign _ }
   '*='            { Token.MultAssign _ }
   '/='            { Token.DivAssign _ }
   '%='            { Token.ModAssign _ }
   '**='           { Token.PowAssign _ }
   '&='            { Token.BinAndAssign _ }
   '|='            { Token.BinOrAssign _ }
   '^='            { Token.BinXorAssign _ }
   '<<='           { Token.LeftShiftAssign _ }
   '>>='           { Token.RightShiftAssign _ }
   '//='           { Token.FloorDivAssign _ } 
   '@'             { Token.At _ }
   '->'            { Token.RightArrow _ }
   'and'           { Token.And _ }
   'as'            { Token.As _ }
   'assert'        { Token.Assert _ }
   'break'         { Token.Break _ }
   'bytestring'    { Token.ByteString _ $$ }
   'class'         { Token.Class _ }
   'continue'      { Token.Continue _ }
   'dedent'        { Token.Dedent _ }
   'def'           { Token.Def _ }
   'del'           { Token.Delete _ }
   'elif'          { Token.Elif _ }
   'else'          { Token.Else _ }
   'except'        { Token.Except _ }
   'False'         { Token.False _ }
   'finally'       { Token.Finally _ }
   'float'         { Token.Float _ $$ }
   'for'           { Token.For _ }
   'from'          { Token.From _ }
   'global'        { Token.Global _ }
   'ident'         { Token.Identifier _ $$ }
   'if'            { Token.If _ }
   'imaginary'     { Token.Imaginary _ $$ }
   'import'        { Token.Import _ }
   'indent'        { Token.Indent _ }
   'in'            { Token.In _ }
   'integer'       { Token.Integer _ $$ }
   'is'            { Token.Is _ }
   'lambda'        { Token.Lambda _ }
   'NEWLINE'       { Token.Newline _ }
   'None'          { Token.None _ }
   'nonlocal'      { Token.NonLocal _ }
   'not'           { Token.Not _ }
   'or'            { Token.Or _ }
   'pass'          { Token.Pass _ }
   'raise'         { Token.Raise _ }
   'return'        { Token.Return _ }
   'string'        { Token.String _ $$ }
   'True'          { Token.True _ }
   'try'           { Token.Try _ }
   'while'         { Token.While _ }
   'with'          { Token.With _ }
   'yield'         { Token.Yield _ }

%%

pair(p,q): p q { ($1, $2) }

left(p,q): p q { $1 }
right(p,q): p q { $2 }

or(p,q)
   : p  { $1 }
   | q  { $1 }

either(p,q)
   : p { Left $1 }
   | q { Right $1 }

opt(p)
   :    { Nothing }
   | p  { Just $1 }

rev_list1(p)
   : p               { [$1] }
   | rev_list1(p) p  { $2 : $1 }

many1(p)
   : rev_list1(p) { reverse $1 }

many0(p)
   : many1(p) { $1 }
   |         { [] }

sepOptEndBy(p,sep) 
   : sepByRev(p,sep) ',' { reverse $1 }
   | sepByRev(p,sep) { reverse $1 }

sepBy(p,sep): sepByRev(p,sep) { reverse $1 }

sepByRev(p,sep)
   : p { [$1] }
   | sepByRev(p,sep) sep p { $3 : $1 }

NAME :: { Ident }
NAME : 'ident' { Ident $1 }

{- 
   Note: newline tokens in the grammar:
   It seems there are some dubious uses of NEWLINE in the grammar. 
   This is corroborated by this posting:
   http://mail.python.org/pipermail/python-dev/2005-October/057014.html
   The general idea is that the lexer does not generate NEWLINE tokens for
   lines which contain only spaces or comments. However, the grammar sometimes
   suggests that such tokens may exist. 
-}

-- single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE 

{- 
   We don't support the newline at the end of a compound stmt 
   because the lexer would not produce a newline there. It seems like a weirdness
   in the way the interactive input works. 
-}

single_input :: { [Statement] }
single_input
   : 'NEWLINE' { [] }
   | simple_stmt { $1 } 
   | compound_stmt {- No newline here! -} { [$1] } 

-- file_input: (NEWLINE | stmt)* ENDMARKER

file_input :: { Module }
file_input 
   : many0(either('NEWLINE',stmt)) {- No need to mention ENDMARKER -} 
     { Module (concat (rights $1)) }

-- eval_input: testlist NEWLINE* ENDMARKER

eval_input :: { Expr }
eval_input : testlist many0('NEWLINE') {- No need to mention ENDMARKER -} { $1 }

--  decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE

opt_paren_arg_list :: { [Argument] }
opt_paren_arg_list: opt(paren_arg_list) { concat (maybeToList $1) }

paren_arg_list :: { [Argument] }
paren_arg_list : '(' optional_arg_list ')' { $2 }

decorator :: { Decorator }
decorator 
   : '@' dotted_name opt_paren_arg_list 'NEWLINE' 
     { Decorator { decorator_name = $2, decorator_args = $3 } }

-- decorators: decorator+

decorators :: { [Decorator] }
decorators : many1(decorator) { $1 }

-- decorated: decorators (classdef | funcdef)

decorated :: { Statement }
decorated 
   : decorators or(classdef,funcdef) 
     { Decorated { decorated_decorators = $1, decorated_def = $2 } } 

-- funcdef: 'def' NAME parameters ['->' test] ':' suite 

funcdef :: { Statement }
funcdef 
   : 'def' NAME parameters opt(right('->',test)) ':' suite
     { Fun { fun_name = $2 , fun_args = $3, fun_result_annotation = $4, fun_body = $6 } }

-- parameters: '(' [typedargslist] ')'

parameters :: { [Parameter] }
parameters : '(' opt(typedargslist) ')' { concat (maybeToList $2) }

{- 
   typedargslist: ((tfpdef ['=' test] ',')*
       ('*' [tfpdef] (',' tfpdef ['=' test])* [',' '**' tfpdef] | '**' tfpdef)
       | tfpdef ['=' test] (',' tfpdef ['=' test])* [',']) 
-} 

{- Same pattern as argslist and varargslist -}

typedargslist :: { [Parameter] }
typedargslist: sepOptEndBy(one_typedargs_param,',') {% checkParameters $1 }

one_typedargs_param :: { Parameter }
one_typedargs_param
   : tfpdef optional_default { makeParam $1 $2 }
   | '*' opt(tfpdef) { makeStarParam $2 }
   | '**' tfpdef { makeStarStarParam $2 }

optional_default :: { Maybe Expr }
optional_default: opt(equals_test) { $1 }

equals_test :: { Expr }
equals_test: '=' test { $2 }

{- tfpdef: NAME [':' test] -}

tfpdef :: { (Ident, Maybe Expr) }
tfpdef : NAME opt(colon_test) { ($1, $2) }

colon_test :: { Expr }
colon_test: ':' test { $2 }

{- 
   varargslist: ((vfpdef ['=' test] ',')* ('*' [vfpdef] (',' vfpdef ['=' test])*  [',' '**' vfpdef] | '**' vfpdef) | vfpdef ['=' test] (',' vfpdef ['=' test])* [','])  

-}

{- 
   There is some tedious similarity in these rules to the ones for
   TypedArgsList. varargslist is used for lambda functions, and they
   do not have parentheses around them (unlike function definitions).
   Therefore lambda parameters cannot have the optional annotations
   that normal functions can, because the annotations are introduced
   using a colon. This would cause ambibguity with the colon
   that marks the end of the lambda parameter list!
-}

varargslist :: { [Parameter] }
varargslist : sepOptEndBy(one_varargs_param,',') {% checkParameters $1 }

one_varargs_param :: { Parameter }
one_varargs_param
   : '*' optvfpdef { makeStarParam $2 }
   | '**' vfpdef { makeStarStarParam ($2, Nothing) } 
   | vfpdef optional_default { makeParam ($1, Nothing) $2 }

-- vfpdef: NAME
vfpdef :: { Ident }
vfpdef : NAME { $1 }

optvfpdef :: { Maybe (Ident, Maybe Expr) }
optvfpdef
   : {- empty -} { Nothing }
   | vfpdef { Just ($1, Nothing) }

-- stmt: simple_stmt | compound_stmt 

stmt :: { [Statement] }
stmt 
   : simple_stmt { $1 }
   | compound_stmt { [$1] }

-- simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE 

simple_stmt :: { [Statement] }
simple_stmt : small_stmts opt(';') 'NEWLINE' { reverse $1 }

small_stmts :: { [Statement] }
small_stmts 
   : small_stmt                 { [$1] }
   | small_stmts ';' small_stmt { $3 : $1 }

{-
small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |
             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)
-}

small_stmt :: { Statement }
small_stmt 
   : expr_stmt     { $1 }
   | del_stmt      { $1 }
   | pass_stmt     { $1 }
   | flow_stmt     { $1 }
   | import_stmt   { $1 }
   | global_stmt   { $1 }
   | nonlocal_stmt { $1 }
   | assert_stmt   { $1 }

-- expr_stmt: testlist_star_expr (augassign (yield_expr|testlist) | ('=' (yield_expr|testlist_star_expr))*)

expr_stmt :: { Statement }
expr_stmt : testlist_star_expr either(many_assign, augassign_yield_or_test_list) { makeAssignmentOrExpr $1 $2 }

many_assign :: { [Expr] }
many_assign : many0(right('=', yield_or_test_list_star)) { $1 }

yield_or_test_list :: { Expr }
yield_or_test_list : or(yield_expr,testlist) { $1 }

yield_or_test_list_star :: { Expr }
yield_or_test_list_star : or(yield_expr,testlist_star_expr) { $1 }

augassign_yield_or_test_list :: { (AssignOp, Expr) }
augassign_yield_or_test_list : augassign yield_or_test_list { ($1, $2) }

-- testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']

testlist_star_expr :: { Expr }
testlist_star_expr: test_list_star_rev opt_comma { makeTupleOrExpr (reverse $1) $2 } 

test_list_star_rev :: { [Expr] }
test_list_star_rev
   : or(test,star_expr) { [$1] }
   | test_list_star_rev ',' or(test,star_expr) { $3 : $1 }

{- 
   augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |
            '<<=' | '>>=' | '**=' | '//=') 
-}

augassign :: { AssignOp }
augassign
   : '+='  { AST.PlusAssign }
   | '-='  { AST.MinusAssign } 
   | '*='  { AST.MultAssign }
   | '/='  { AST.DivAssign }
   | '%='  { AST.ModAssign } 
   | '**=' { AST.PowAssign }
   | '&='  { AST.BinAndAssign } 
   | '|='  { AST.BinOrAssign }
   | '^='  { AST.BinXorAssign }
   | '<<=' { AST.LeftShiftAssign }
   | '>>=' { AST.RightShiftAssign }
   | '//=' { AST.FloorDivAssign } 

-- del_stmt: 'del' exprlist

del_stmt :: { Statement }
del_stmt : 'del' exprlist { AST.Delete { del_exprs = $2 } }

-- pass_stmt: 'pass'

pass_stmt :: { Statement }
pass_stmt : 'pass' { AST.Pass }

-- flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt

flow_stmt :: { Statement }
flow_stmt 
   : break_stmt    { $1 }
   | continue_stmt { $1 }
   | return_stmt   { $1 }
   | raise_stmt    { $1 }
   | yield_stmt    { $1 }

-- break_stmt: 'break'

break_stmt :: { Statement }
break_stmt : 'break' { AST.Break }  

-- continue_stmt: 'continue'

continue_stmt :: { Statement }
continue_stmt : 'continue' { AST.Continue }  

-- return_stmt: 'return' [testlist]

return_stmt :: { Statement }
return_stmt : 'return' optional_testlist { AST.Return { return_expr = $2 }}

-- yield_stmt: yield_expr

yield_stmt :: { Statement }
yield_stmt : yield_expr { StmtExpr { stmt_expr = $1 } } 

-- raise_stmt: 'raise' [test ['from' test]]

raise_stmt :: { Statement }
raise_stmt : 'raise' opt(pair(test, opt(right('from', test)))) { AST.Raise { raise_expr = $2 }}

-- import_stmt: import_name | import_from

import_stmt :: { Statement }
import_stmt: or(import_name, import_from) { $1 }

-- import_name: 'import' dotted_as_names

import_name :: { Statement }
import_name : 'import' dotted_as_names { AST.Import { import_items = $2 }}

{-
   # note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS
   import_from: ('from' (('.' | '...')* dotted_name | ('.' | '...')+)
                 'import' ('*' | '(' import_as_names ')' | import_as_names))
-}

import_from :: { Statement }
import_from : 'from' import_module 'import' star_or_as_names 
              { FromImport { from_module = $2, from_items = $4 }}

import_module :: { ImportModule }
import_module
   : '.'                 { ImportDot }
   | '...'               { ImportRelative (ImportRelative ImportDot) }
   | dotted_name         { ImportName $1 }
   | '.' import_module   { ImportRelative $2 }
   | '...' import_module { ImportRelative (ImportRelative (ImportRelative $2)) }

star_or_as_names :: { FromItems }
star_or_as_names
   : '*'                     { ImportEverything }
   | '(' import_as_names ')' { $2 }
   | import_as_names         { $1 } 

-- import_as_name: NAME ['as' NAME]
import_as_name :: { FromItem }
import_as_name 
   : NAME optional_as_name { FromItem { from_item_name = $1, from_as_name = $2 }}

-- dotted_as_name: dotted_name ['as' NAME]

dotted_as_name :: { ImportItem }
dotted_as_name 
   : dotted_name optional_as_name  
     { ImportItem { import_item_name = $1, import_as_name = $2 }}

-- import_as_names: import_as_name (',' import_as_name)* [',']

import_as_names :: { FromItems }
import_as_names : sepOptEndBy(import_as_name, ',') { FromItems $1 }

-- dotted_as_names: dotted_as_name (',' dotted_as_name)*

dotted_as_names :: { [ImportItem] }
dotted_as_names : sepBy(dotted_as_name,',') { $1 }

-- dotted_name: NAME ('.' NAME)* 

dotted_name :: { DottedName }
dotted_name : NAME many0(right('.', NAME)) { $1 : $2 }

-- global_stmt: 'global' NAME (',' NAME)*

global_stmt :: { Statement }
global_stmt : 'global' one_or_more_names { AST.Global { global_vars = $2 }}

one_or_more_names :: { [Ident] }
one_or_more_names: sepBy(NAME, ',') { $1 }

-- nonlocal_stmt: 'nonlocal' NAME (',' NAME)*

nonlocal_stmt :: { Statement }
nonlocal_stmt : 'nonlocal' one_or_more_names { AST.NonLocal { nonLocal_vars = $2 }}

-- assert_stmt: 'assert' test [',' test]

assert_stmt :: { Statement }
assert_stmt : 'assert' sepBy(test,',') { AST.Assert { assert_exprs = $2 }}

-- compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated 

compound_stmt :: { Statement }
compound_stmt 
   : if_stmt    { $1 } 
   | while_stmt { $1 }
   | for_stmt   { $1 }
   | try_stmt   { $1 }
   | with_stmt  { $1 }
   | funcdef    { $1 } 
   | classdef   { $1 }
   | decorated  { $1 }

-- if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]

if_stmt :: { Statement }
if_stmt : 'if' test ':' suite many0(elif) optional_else 
          { Conditional { cond_guards = ($2, $4):$5, cond_else = $6 } }

elif :: { (Expr, [Statement]) }
elif : 'elif' test ':' suite { ($2, $4) }

optional_else :: { [Statement] }
optional_else 
   : {- empty -} { [] }
   | 'else' ':' suite { $3 }

-- while_stmt: 'while' test ':' suite ['else' ':' suite] 

while_stmt :: { Statement }
while_stmt 
   : 'while' test ':' suite optional_else 
     { AST.While { while_cond = $2 , while_body = $4, while_else = $5 } }

-- for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] 

for_stmt :: { Statement }
for_stmt 
   : 'for' exprlist 'in' testlist ':' suite optional_else 
     { AST.For { for_targets = $2, for_generator = $4, for_body = $6, for_else = $7 } }

{- 
   try_stmt: ('try' ':' suite 
               ((except_clause ':' suite)+ ['else' ':' suite] ['finally' ':' suite] | 'finally' ':' suite))
-}

try_stmt :: { Statement }
try_stmt : 'try' ':' suite handlers { makeTry $3 $4 }

handlers :: { ([Handler], [Statement], [Statement]) }
handlers 
   : one_or_more_except_clauses optional_else optional_finally { ($1, $2, $3) }
   | 'finally' ':' suite { ([], [], $3) }

optional_finally :: { [Statement] }
optional_finally 
   : {- empty -} { [] }
   | 'finally' ':' suite { $3 }

one_or_more_except_clauses :: { [Handler] }
one_or_more_except_clauses : many1(handler) { $1 }

handler :: { Handler }
handler : except_clause ':' suite { ($1, $3) }

-- with_stmt: 'with' with_item (',' with_item)*  ':' suite

with_stmt :: { Statement }
with_stmt : 'with' sepOptEndBy(with_item, ',') ':' suite 
           { AST.With { with_context = $2, with_body = $4 } }

-- with_item: test ['as' expr]

with_item :: { (Expr, Maybe Expr) }
with_item: pair(test,opt(right('as',expr))) { $1 }

-- except_clause: 'except' [test ['as' NAME]] 

except_clause :: { ExceptClause }
except_clause : right('except', opt(pair(test, optional_as_name))) { $1 }

optional_as_name :: { Maybe Ident }
optional_as_name: opt(right('as', NAME)) { $1 }

-- suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT 
-- Note: we don't have a newline before indent b/c it is redundant

suite :: { [Statement] }
suite 
   : simple_stmt { $1 }
   | {- no newline here! -} 'indent' many1(stmt) 'dedent' { concat $2 } 

-- test: or_test ['if' or_test 'else' test] | lambdef

test :: { Expr }
test 
   : or_test opt(test_if_cond) { makeConditionalExpr $1 $2 }
   | lambdef { $1 }

test_if_cond :: { (Expr, Expr) }
test_if_cond: 'if' or_test 'else' test { ($2, $4) }

-- test_nocond: or_test | lambdef_nocond

test_no_cond :: { Expr }
test_no_cond: or(or_test, lambdef_nocond) { $1 }

-- lambdef: 'lambda' [varargslist] ':' test

lambdef :: { Expr }
lambdef : 'lambda' opt_varargslist ':' test { AST.Lambda $2 $4 }

-- lambdef_nocond: 'lambda' [varargslist] ':' test_nocond

lambdef_nocond :: { Expr }
lambdef_nocond : 'lambda' opt_varargslist ':' test_no_cond { AST.Lambda $2 $4 }

opt_varargslist :: { [Parameter] }
opt_varargslist: opt(varargslist) { concat (maybeToList $1) }

-- or_test: and_test ('or' and_test)* 

or_test :: { Expr }
or_test : and_test many0(pair(or_op,and_test)) { makeBinOp $1 $2 }

or_op :: { Op }
or_op: 'or' { AST.Or }

-- and_test: not_test ('and' not_test)* 

and_test :: { Expr }
and_test : not_test many0(pair(and_op, not_test)) { makeBinOp $1 $2 }

and_op :: { Op }
and_op: 'and' { AST.And }

-- not_test: 'not' not_test | comparison 

not_test :: { Expr }
not_test
   : 'not' not_test { UnaryOp {operator = AST.Not, op_arg = $2} }
   | comparison { $1 }

-- comparison: expr (comp_op expr)*

comparison :: { Expr }
comparison : expr many0(pair(comp_op, expr)) { makeBinOp $1 $2 }

-- comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'|'is' 'not' 

comp_op :: { Op }
comp_op
   : '<'        { AST.LessThan }
   | '>'        { AST.GreaterThan }
   | '=='       { AST.Equality }
   | '>='       { AST.GreaterThanEquals }
   | '<='       { AST.LessThanEquals }
   | '!='       { AST.NotEquals }
   | 'in'       { AST.In }
   | 'not' 'in' { AST.NotIn }
   | 'is'       { AST.Is }
   | 'is' 'not' { AST.IsNot }

-- star_expr: '*' expr

star_expr :: { Expr }
star_expr : '*' expr { $2 }

-- expr: xor_expr ('|' xor_expr)* 

expr :: { Expr }
expr : xor_expr many0(pair(bar_op, xor_expr)) { makeBinOp $1 $2 }

bar_op :: { Op }
bar_op: '|' { AST.BinaryOr }

-- xor_expr: and_expr ('^' and_expr)* 

xor_expr :: { Expr }
xor_expr : and_expr many0(pair(hat_op, and_expr)) { makeBinOp $1 $2 }

hat_op :: { Op }
hat_op: '^' { AST.Xor }

-- and_expr: shift_expr ('&' shift_expr)* 

and_expr :: { Expr }
and_expr : shift_expr many0(pair(ampersand, shift_expr)) { makeBinOp $1 $2 }

ampersand :: { Op }
ampersand: '&' { AST.BinaryAnd }

-- shift_expr: arith_expr (('<<'|'>>') arith_expr)* 

shift_expr :: { Expr }
shift_expr: arith_expr many0(pair(shift_op, arith_expr)) { makeBinOp $1 $2 }

shift_op :: { Op }
shift_op 
   : '<<' { AST.ShiftLeft }
   | '>>' { AST.ShiftRight }

-- arith_expr: term (('+'|'-') term)*

arith_expr :: { Expr }
arith_expr: term many0(pair(arith_op, term)) { makeBinOp $1 $2 }

arith_op :: { Op }
arith_op
   : '+' { AST.Plus }
   | '-' { AST.Minus }

-- term: factor (('*'|'/'|'%'|'//') factor)* 

term :: { Expr }
term : factor many0(pair(mult_div_mod_op, factor)) { makeBinOp $1 $2 }

mult_div_mod_op :: { Op }
mult_div_mod_op
   : '*'  { AST.Multiply } 
   | '/'  { AST.Divide }
   | '%'  { AST.Modulo }
   | '//' { AST.FloorDivide }

-- factor: ('+'|'-'|'~') factor | power 

factor :: { Expr }
factor 
   : or(arith_op, tilde_op) factor { UnaryOp { operator = $1, op_arg = $2 } } 
   | power { $1 }

tilde_op :: { Op }
tilde_op: '~' { AST.Invert }

-- power: atom trailer* ['**' factor]

power :: { Expr }
power : atom many0(trailer) opt(pair(exponent_op, factor)) 
        { makeBinOp (addTrailer $1 $2) (maybeToList $3) } 

exponent_op :: { Op }
exponent_op: '**' { AST.Exponent }

{- 
   atom: ('(' [yield_expr|testlist_comp] ')' |
          '[' [testlist_comp] ']' |
          '{' [dictorsetmaker] '}' |
           NAME | NUMBER | STRING+ | '...' | 'None' | 'True' | 'False')
-}

atom :: { Expr }
atom : '(' yield_or_testlist_comp ')' { $2 } 
     | list_atom                      { $1 }
     | dict_or_set_atom               { $1 }
     | NAME                           { AST.Var $1 }
     | 'integer'                      { AST.Int $1 }
     | 'float'                        { AST.Float $1 }
     | 'imaginary'                    { AST.Imaginary { imaginary_value = $1 }}
     | many1('string')                { AST.Strings (reverse $1) }
     | many1('bytestring')            { AST.ByteStrings (reverse $1) }
     | '...'                          { AST.Ellipsis }
     | 'None'                         { AST.None }
     | 'True'                         { AST.Bool Prelude.True }
     | 'False'                        { AST.Bool Prelude.False }

list_atom :: { Expr }
list_atom
   : '[' ']' { List { list_exprs = [] } }
   | '[' testlist_comp ']' { makeListForm $2 }

dict_or_set_atom :: { Expr }
dict_or_set_atom
   : '{' '}' { Dictionary { dict_mappings = [] }}
   | '{' dictorsetmaker '}' { $2 }

yield_or_testlist_comp :: { Expr }
yield_or_testlist_comp 
   : {- empty -} { Tuple { tuple_exprs = [] } }
   | yield_expr { $1 }
   | testlist_comp { either id (\c -> Generator { gen_comprehension = c }) $1 } 

-- testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] )

testlist_comp :: { Either Expr (Comprehension Expr) }
testlist_comp
   : testlist_star_expr { Left $1 }
   | or(test,star_expr) comp_for { Right (makeComprehension $1 $2) }

-- trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME 

trailer :: { Trailer }
trailer 
   : paren_arg_list { TrailerCall $1 }
   | '[' subscriptlist ']' { TrailerSubscript $2 } 
   | '.' NAME { TrailerDot $2 }

-- subscriptlist: subscript (',' subscript)* [',']

subscriptlist :: { [Subscript] }
subscriptlist : sepOptEndBy(subscript, ',') { $1 }

-- subscript: test | [test] ':' [test] [sliceop]

subscript :: { Subscript }
subscript
   : test { SubscriptExpr $1 }
   | opt(test) ':' opt(test) opt(sliceop) { SubscriptSlice $1 $3 $4 }

-- sliceop: ':' [test]

sliceop :: { Maybe Expr }
sliceop : ':' opt(test) { $2 }

-- exprlist: (expr|star_expr) (',' (expr|star_expr))* [',']

exprlist :: { [Expr] }
exprlist: sepOptEndBy(or(expr,star_expr), ',') { $1 }

opt_comma :: { Bool }
opt_comma 
   : {- empty -} { False }
   | ','         { True }  

-- testlist: test (',' test)* [',']

-- Some trickery here because the of the optional trailing comma, which
-- could turn a normal expression into a tuple.
-- Very occasionally, testlist is used to generate something which is not
-- a tuple (such as the square bracket notation in list literals). Therefore
-- it would seem like a good idea to not return a tuple in this case, but
-- a list of expressions. However this would complicate a lot of code
-- since we would have to carry around the optional comma information.
-- I've decided to leave it as a tuple, and in special cases, unpack the
-- tuple and pull out the list of expressions.

testlist :: { Expr }
testlist : testlistrev opt_comma { makeTupleOrExpr (reverse $1) $2 }

testlistrev :: { [Expr] }
testlistrev 
   : test { [$1] }
   | testlistrev ',' test { $3 : $1 }

{- 
   dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |
                   (test (comp_for | (',' test)* [','])) )
-}

dictorsetmaker :: { Expr }
dictorsetmaker
   : test ':' test dict_rest { makeDictionary ($1, $3) $4 } 
   | test set_rest { makeSet $1 $2 } 

dict_rest :: { Either CompFor [(Expr, Expr)] }
dict_rest 
   : comp_for { Left $1 }
   | zero_or_more_dict_mappings_rev opt_comma { Right (reverse $1) }

zero_or_more_dict_mappings_rev :: { [(Expr, Expr)] }
zero_or_more_dict_mappings_rev
   : {- empty -} { [] }
   | zero_or_more_dict_mappings_rev ',' test ':' test { ($3,$5) : $1 }

set_rest :: { Either CompFor [Expr] }
set_rest
   : comp_for { Left $1 }
   | zero_or_more_comma_test_rev opt_comma { Right (reverse $1) }

zero_or_more_comma_test_rev :: { [Expr] }
zero_or_more_comma_test_rev
   : {- empty -} { [] }
   | zero_or_more_comma_test_rev ',' test { $3 : $1 }

-- classdef: 'class' NAME ['(' [arglist] ')'] ':' suite

classdef :: { Statement }
classdef 
   : 'class' NAME opt_paren_arg_list ':' suite 
     { AST.Class { class_name = $2, class_args = $3, class_body = $5 }}

optional_arg_list :: { [Argument] }
optional_arg_list: opt(arglist) { concat (maybeToList $1) } 

{- 
   arglist: (argument ',')* (argument [',']
                         |'*' test (',' argument)* [',' '**' test]
                         |'**' test)
-}

{-
   We don't follow the grammar rules directly (though we do implement
   something equivalent). The reason is that there is ambiguity over
   the optional comma.

   It is probably okay to allow the optional comma even after the *, and
   ** forms. It seems more consistent to me.
-}

arglist :: { [Argument] }
arglist: sepOptEndBy(oneArgument,',') {% checkArguments $1 }

oneArgument
   : '*' test { ArgVarArgsPos { arg_expr = $2 } }
   | '**' test { ArgVarArgsKeyword { arg_expr = $2 } }
   | argument { $1 }

-- argument: test [comp_for] | test '=' test  # Really [keyword '='] test

argument :: { Argument }
argument
   : NAME '=' test { ArgKeyword { arg_keyword = $1, arg_expr = $3 }}
   | test { ArgExpr { arg_expr = $1 }} 
   | test comp_for { ArgExpr { arg_expr = Generator { gen_comprehension = makeComprehension $1 $2 }}}

-- comp_iter: comp_for | comp_if

comp_iter :: { CompIter }
comp_iter
   : comp_for { IterFor $1 }
   | comp_if  { IterIf $1 } 

-- comp_for: 'for' exprlist 'in' or_test [comp_iter]

comp_for :: { CompFor }
comp_for 
   : 'for' exprlist 'in' or_test opt(comp_iter) 
     { CompFor { comp_for_exprs = $2, comp_in_expr = $4, comp_for_iter = $5 }}

-- comp_if: 'if' test_nocond [comp_iter]

comp_if :: { CompIf }
comp_if 
   : 'if' test_no_cond opt(comp_iter) { CompIf { comp_if = $2, comp_if_iter = $3 } }

-- encoding_decl: NAME
-- Not used in the rest of the grammar!

-- yield_expr: 'yield' [testlist] 

yield_expr :: { Expr }
yield_expr : 'yield' optional_testlist { AST.Yield { yield_expr = $2 } }

optional_testlist :: { Maybe Expr }
optional_testlist: opt(testlist) { $1 }

{
-- Put additional Haskell code in here if needed.
}
